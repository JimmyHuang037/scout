============================= test session starts ==============================
platform linux -- Python 3.13.3, pytest-7.4.0, pluggy-1.6.0
rootdir: /home/jimmy/repo/scout/api
configfile: pytest.ini
testpaths: tests
plugins: cov-4.1.0, mock-3.14.1
collected 174 items

tests/test_curl/test_admin_endpoints.py 正在恢复测试数据库...
使用备份文件: /home/jimmy/repo/scout/api/tests/../../db/backup/school_management_backup_20250831_103236.sql
数据库恢复成功完成!
测试数据库恢复成功!
测试环境已设置: FLASK_ENV=testing
登录管理员账户...
登录结果: returncode=0, stdout={
  "data": {
    "role": "admin",
    "user_id": "admin",
    "user_name": "admin"
  },
  "message": "Success",
  "success": true
}
, stderr=
管理员登录成功

1. 获取学生列表
执行命令: curl -s http://127.0.0.1:5010/api/admin/students -b /tmp/test_cookie.txt
测试 1 完成
.
2. 创建学生
执行命令: curl -s -X POST http://127.0.0.1:5010/api/admin/students -H Content-Type: application/json -d {"student_id": "S9999", "student_name": "张三", "class_id": 1, "password": "pass123"} -b /tmp/test_cookie.txt
测试 2 失败: API返回错误 - 创建学生失败
测试 2 异常: 测试 2 失败: API返回错误 - 创建学生失败
assert False
F
3. 获取特定学生
执行命令: curl -s http://127.0.0.1:5010/api/admin/students/S0201 -b /tmp/test_cookie.txt
测试 3 失败: API返回错误 - 学生不存在
测试 3 异常: 测试 3 失败: API返回错误 - 学生不存在
assert False
F
4. 更新学生信息
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/admin/students/S0201 -H Content-Type: application/json -d {"student_name": "更新的学生姓名"} -b /tmp/test_cookie.txt
测试 4 失败: API返回错误 - 学生不存在
测试 4 异常: 测试 4 失败: API返回错误 - 学生不存在
assert False
F
5. 删除学生
执行命令: curl -s -X DELETE http://127.0.0.1:5010/api/admin/students/S0201 -b /tmp/test_cookie.txt
测试 5 失败: API返回错误 - 学生不存在
测试 5 异常: 测试 5 失败: API返回错误 - 学生不存在
assert False
F
6. 获取教师列表
执行命令: curl -s http://127.0.0.1:5010/api/admin/teachers -b /tmp/test_cookie.txt
测试 6 完成
.
7. 创建教师
执行命令: curl -s -X POST http://127.0.0.1:5010/api/admin/teachers -H Content-Type: application/json -d {"teacher_name": "李老师", "subject_id": 1, "password": "pass123"} -b /tmp/test_cookie.txt
测试 7 完成
.
8. 获取特定教师
执行命令: curl -s http://127.0.0.1:5010/api/admin/teachers/3 -b /tmp/test_cookie.txt
测试 8 完成
.
9. 更新教师信息
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/admin/teachers/3 -H Content-Type: application/json -d {"teacher_name": "更新的张老师", "subject_id": 2} -b /tmp/test_cookie.txt
测试 9 失败: API返回错误 - 教师不存在
测试 9 异常: 测试 9 失败: API返回错误 - 教师不存在
assert False
F
10. 删除教师
执行命令: curl -s -X DELETE http://127.0.0.1:5010/api/admin/teachers/999 -b /tmp/test_cookie.txt
测试 10 完成（预期错误）: API返回错误 - 教师不存在
.
11. 获取班级列表
执行命令: curl -s http://127.0.0.1:5010/api/admin/classes -b /tmp/test_cookie.txt
测试 11 完成
.
12. 创建班级
执行命令: curl -s -X POST http://127.0.0.1:5010/api/admin/classes -H Content-Type: application/json -d {"class_name": "高三X班", "grade_id": 3} -b /tmp/test_cookie.txt
测试 12 完成
.
13. 获取特定班级
执行命令: curl -s http://127.0.0.1:5010/api/admin/classes/1 -b /tmp/test_cookie.txt
测试 13 失败: API返回错误 - Class not found
测试 13 异常: 测试 13 失败: API返回错误 - Class not found
assert False
F
14. 更新班级信息
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/admin/classes/1 -H Content-Type: application/json -d {"class_name": "更新的班级名称"} -b /tmp/test_cookie.txt
测试 14 完成
.
15. 删除班级
执行命令: curl -s -X DELETE http://127.0.0.1:5010/api/admin/classes/1 -b /tmp/test_cookie.txt
测试 15 完成
.
16. 获取科目列表
执行命令: curl -s http://127.0.0.1:5010/api/admin/subjects -b /tmp/test_cookie.txt
测试 16 完成
.
17. 创建科目
执行命令: curl -s -X POST http://127.0.0.1:5010/api/admin/subjects -H Content-Type: application/json -d {"subject_name": "新科目", "description": "科目描述"} -b /tmp/test_cookie.txt
测试 17 完成
.
18. 获取特定科目
执行命令: curl -s http://127.0.0.1:5010/api/admin/subjects/15 -b /tmp/test_cookie.txt
测试 18 完成
.
19. 更新科目信息
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/admin/subjects/15 -H Content-Type: application/json -d {"subject_name": "更新的科目名称"} -b /tmp/test_cookie.txt
测试 19 完成
.
20. 删除科目
执行命令: curl -s -X DELETE http://127.0.0.1:5010/api/admin/subjects/15 -b /tmp/test_cookie.txt
测试 20 完成
.
21. 获取考试类型列表
执行命令: curl -s http://127.0.0.1:5010/api/admin/exam-types -b /tmp/test_cookie.txt
测试 21 完成
.
22. 创建考试类型
执行命令: curl -s -X POST http://127.0.0.1:5010/api/admin/exam-types -H Content-Type: application/json -d {"exam_type_name": "新考试类型1", "description": "考试类型描述"} -b /tmp/test_cookie.txt
测试 22 失败: API返回错误 - 创建考试类型失败
测试 22 异常: 测试 22 失败: API返回错误 - 创建考试类型失败
assert False
F
23. 获取特定考试类型
执行命令: curl -s http://127.0.0.1:5010/api/admin/exam-types/2 -b /tmp/test_cookie.txt
测试 23 失败: API返回错误 - 考试类型不存在
测试 23 异常: 测试 23 失败: API返回错误 - 考试类型不存在
assert False
F
24. 更新考试类型信息
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/admin/exam-types/2 -H Content-Type: application/json -d {"exam_type_name": "更新的考试类型名称"} -b /tmp/test_cookie.txt
测试 24 失败: API返回错误 - 考试类型不存在
测试 24 异常: 测试 24 失败: API返回错误 - 考试类型不存在
assert False
F
25. 删除考试类型
执行命令: curl -s -X DELETE http://127.0.0.1:5010/api/admin/exam-types/2 -b /tmp/test_cookie.txt
测试 25 失败: API返回错误 - 考试类型不存在
测试 25 异常: 测试 25 失败: API返回错误 - 考试类型不存在
assert False
F
26. 获取教师班级关系列表
执行命令: curl -s http://127.0.0.1:5010/api/admin/teacher-classes -b /tmp/test_cookie.txt
测试 26 完成
.
27. 创建教师班级关系
执行命令: curl -s -X POST http://127.0.0.1:5010/api/admin/teacher-classes -H Content-Type: application/json -d {"teacher_id": 4, "class_id": 2} -b /tmp/test_cookie.txt
测试 27 完成
.
28. 获取特定教师班级关系
执行命令: curl -s http://127.0.0.1:5010/api/admin/teacher-classes/1 -b /tmp/test_cookie.txt
测试 28 完成
.
29. 更新教师班级关系
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/admin/teacher-classes/1 -H Content-Type: application/json -d {"teacher_id": 4, "class_id": 2} -b /tmp/test_cookie.txt
测试 29 完成
.
30. 删除教师班级关系
执行命令: curl -s -X DELETE http://127.0.0.1:5010/api/admin/teacher-classes/4?class_id=2 -b /tmp/test_cookie.txt
测试 30 完成
.登出账户...
登出结果: {
  "data": {
    "message": "Logged out successfully"
  },
  "message": "Success",
  "success": true
}


tests/test_curl/test_student_endpoints.py E
tests/test_curl/test_teacher_endpoints.py 
1. 教师获取任教班级列表
执行命令: curl -s http://127.0.0.1:5010/api/teacher/exam-classes -b /tmp/test_cookie.txt
测试 1 完成
.
2. 教师获取学生成绩列表
执行命令: curl -s http://127.0.0.1:5010/api/teacher/scores -b /tmp/test_cookie.txt
测试 2 完成
.
3. 教师创建学生成绩
执行命令: curl -s -X POST http://127.0.0.1:5010/api/teacher/scores -H Content-Type: application/json -d {"student_id": "S0201", "subject_id": 1, "exam_type_id": 1, "score": 85} -b /tmp/test_cookie.txt
测试 3 失败: API返回错误 - Failed to create score
测试 3 异常: 测试 3 失败: API返回错误 - Failed to create score
assert False
F
4. 教师更新学生成绩 - 正常情况
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/teacher/scores/1 -H Content-Type: application/json -d {"score": 92} -b /tmp/test_cookie.txt
测试 4 完成
.
5. 教师更新学生成绩 - 更新不存在的成绩
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/teacher/scores/999 -H Content-Type: application/json -d {"score": 85} -b /tmp/test_cookie.txt
测试 5 完成
.
6. 教师更新学生成绩 - 分数超出范围
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/teacher/scores/1 -H Content-Type: application/json -d {"score": 150} -b /tmp/test_cookie.txt
测试 6 完成
.
8. 教师删除学生成绩
执行命令: curl -s -X DELETE http://127.0.0.1:5010/api/teacher/scores/1 -b /tmp/test_cookie.txt
测试 8 完成
.
8. 获取班级列表
执行命令: curl -s http://127.0.0.1:5010/api/teacher/classes -b /tmp/test_cookie.txt
测试 8 完成
.
9. 获取班级学生列表
执行命令: curl -s http://127.0.0.1:5010/api/teacher/classes/1/students -b /tmp/test_cookie.txt
测试 9 完成
.
10. 教师获取考试列表
执行命令: curl -s http://127.0.0.1:5010/api/teacher/exams -b /tmp/test_cookie.txt
测试 10 完成
.
10. 教师创建考试
执行命令: curl -s -X POST http://127.0.0.1:5010/api/teacher/exams -H Content-Type: application/json -d {"name": "Midterm Exam", "subject_id": 1, "class_ids": [1], "exam_type_id": 1, "date": "2025-10-15", "total_score": 100} -b /tmp/test_cookie.txt
测试 10 完成
.
11. 教师获取特定考试
执行命令: curl -s http://127.0.0.1:5010/api/teacher/exams/1 -b /tmp/test_cookie.txt
测试 11 完成
.
12. 教师更新考试信息
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/teacher/exams/1 -H Content-Type: application/json -d {"exam_name": "Updated Midterm Exam", "exam_date": "2025-10-20"} -b /tmp/test_cookie.txt
测试 12 完成
.
13. 教师删除考试
执行命令: curl -s -X DELETE http://127.0.0.1:5010/api/teacher/exams/1 -b /tmp/test_cookie.txt
测试 13 完成
.
14. 教师获取考试结果
执行命令: curl -s http://127.0.0.1:5010/api/teacher/exam-results -b /tmp/test_cookie.txt
测试 14 完成
.
15. 教师获取教学表现统计
执行命令: curl -s http://127.0.0.1:5010/api/teacher/performance -b /tmp/test_cookie.txt
测试 15 完成
.
16. 教师获取学生列表
执行命令: curl -s http://127.0.0.1:5010/api/teacher/students -b /tmp/test_cookie.txt
测试 16 完成
.
17. 教师获取特定学生
执行命令: curl -s http://127.0.0.1:5010/api/teacher/students/S0201 -b /tmp/test_cookie.txt
测试 17 失败: API返回错误 - Student not found or not in your class
测试 17 异常: 测试 17 失败: API返回错误 - Student not found or not in your class
assert False
F
18. 教师更新学生信息
执行命令: curl -s -X PUT http://127.0.0.1:5010/api/teacher/students/S0201 -H Content-Type: application/json -d {"student_name": "Updated Name"} -b /tmp/test_cookie.txt
测试 18 失败: API返回错误 - Student not found or not in your class
测试 18 异常: 测试 18 失败: API返回错误 - Student not found or not in your class
assert False
F
19. 教师获取教师列表
执行命令: curl -s http://127.0.0.1:5010/api/teacher/teachers -b /tmp/test_cookie.txt
测试 19 完成
.
20. 教师获取特定教师信息
执行命令: curl -s http://127.0.0.1:5010/api/teacher/teachers/1 -b /tmp/test_cookie.txt
测试 20 完成
.
tests/test_py/app/test_app.py ..
tests/test_py/app/test_routes.py .
tests/test_py/blueprints/admin/test_class_management.py .....
tests/test_py/blueprints/admin/test_exam_type_management.py .....
tests/test_py/blueprints/admin/test_student_management.py .....
tests/test_py/blueprints/admin/test_subject_management.py .....
tests/test_py/blueprints/admin/test_teacher_class_management.py .....
tests/test_py/blueprints/admin/test_teacher_management.py .....
tests/test_py/blueprints/auth/test_auth_management.py .....
tests/test_py/blueprints/student/test_exam_management.py .
tests/test_py/blueprints/student/test_profile_management.py .
tests/test_py/blueprints/student/test_scores.py ..
tests/test_py/blueprints/teacher/test_score_management.py ..
tests/test_py/blueprints/teacher/test_teacher_exam_class_management.py .
tests/test_py/blueprints/teacher/test_teacher_exam_management.py .....
tests/test_py/blueprints/teacher/test_teacher_exam_results_management.py ..
tests/test_py/blueprints/teacher/test_teacher_performance_management.py ..
tests/test_py/blueprints/teacher/test_teacher_score_management.py ....
tests/test_py/blueprints/teacher/test_teacher_student_management.py ..
tests/test_py/services/test_class_service.py .....
tests/test_py/services/test_exam_service.py ...........
tests/test_py/services/test_exam_type_service.py .....
tests/test_py/services/test_score_service.py ...........
tests/test_py/services/test_student_service.py .....
tests/test_py/services/test_subject_service.py .....
tests/test_py/services/test_teacher_class_service.py .......
tests/test_py/services/test_teacher_service.py .....
tests/test_py/utils/test_auth.py ...
tests/test_py/utils/test_db.py ..
tests/test_py/utils/test_helpers.py ...

==================================== ERRORS ====================================
__________ ERROR at setup of TestStudentEndpoints.test_01_get_grades ___________

cls = <class 'tests.test_curl.test_student_endpoints.TestStudentEndpoints'>

    @classmethod
    def setup_class(cls):
        """测试类级别的设置"""
        # 调用父类的setup_class
        super().setup_class()
    
        cls.cookie_file = "/tmp/test_cookie.txt"
        cls.test_results_dir = TestingConfig.CURL_TEST_DIR
        cls.curl_commands_file = os.path.join(cls.test_results_dir, "student_curl_commands.log")
    
        # 清理之前的cookie文件
        if os.path.exists(cls.cookie_file):
            os.remove(cls.cookie_file)
    
        # 登录学生账户
        login_data = {
            "user_id": "S0101",
            "password": "pass123"
        }
        import json
        import subprocess
        curl_cmd = [
            "curl", "-s", "-X", "POST", f"{cls.base_url}/api/auth/login",
            "-H", "Content-Type: application/json",
            "-d", json.dumps(login_data),
            "-c", cls.cookie_file
        ]
    
        result = subprocess.run(curl_cmd, capture_output=True, text=True)
        assert result.returncode == 0, f"学生登录失败: {result.stderr}"
    
        response_data = json.loads(result.stdout)
>       assert response_data.get("success"), f"学生登录失败: {response_data.get('message', 'Unknown error')}"
E       AssertionError: 学生登录失败: Unknown error
E       assert False
E        +  where False = <built-in method get of dict object at 0x7f6e402fe2c0>('success')
E        +    where <built-in method get of dict object at 0x7f6e402fe2c0> = {'error': 'Invalid credentials', 'success': False}.get

tests/test_curl/test_student_endpoints.py:51: AssertionError
=================================== FAILURES ===================================
__________________ TestAdminEndpoints.test_02_create_student ___________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e40698cd0>
test_number = 2, description = '创建学生'
command = ['curl', '-s', '-X', 'POST', 'http://127.0.0.1:5010/api/admin/students', '-H', ...]
output_file = '2_create_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 2 失败: API返回错误 - 创建学生失败
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e40698cd0>

    def test_02_create_student(self):
        """测试用例2: 创建学生"""
>       self.run_api_test(
            2, "创建学生",
            ['curl', '-s', '-X', 'POST', f'{self.base_url}/api/admin/students',
             '-H', 'Content-Type: application/json',
             '-d', '{"student_id": "S9999", "student_name": "张三", "class_id": 1, "password": "pass123"}',
             '-b', self.cookie_file],
            "2_create_student.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e40698cd0>
test_number = 2, description = '创建学生'
command = ['curl', '-s', '-X', 'POST', 'http://127.0.0.1:5010/api/admin/students', '-H', ...]
output_file = '2_create_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 2 异常: 测试 2 失败: API返回错误 - 创建学生失败
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
____________________ TestAdminEndpoints.test_03_get_student ____________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e405db820>
test_number = 3, description = '获取特定学生'
command = ['curl', '-s', 'http://127.0.0.1:5010/api/admin/students/S0201', '-b', '/tmp/test_cookie.txt']
output_file = '3_get_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 3 失败: API返回错误 - 学生不存在
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e405db820>

    def test_03_get_student(self):
        """测试用例3: 获取特定学生"""
>       self.run_api_test(
            3, "获取特定学生",
            ['curl', '-s', f'{self.base_url}/api/admin/students/S0201', '-b', self.cookie_file],
            "3_get_student.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e405db820>
test_number = 3, description = '获取特定学生'
command = ['curl', '-s', 'http://127.0.0.1:5010/api/admin/students/S0201', '-b', '/tmp/test_cookie.txt']
output_file = '3_get_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 3 异常: 测试 3 失败: API返回错误 - 学生不存在
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
__________________ TestAdminEndpoints.test_04_update_student ___________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e405dba80>
test_number = 4, description = '更新学生信息'
command = ['curl', '-s', '-X', 'PUT', 'http://127.0.0.1:5010/api/admin/students/S0201', '-H', ...]
output_file = '4_update_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 4 失败: API返回错误 - 学生不存在
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e405dba80>

    def test_04_update_student(self):
        """测试用例4: 更新学生信息"""
>       self.run_api_test(
            4, "更新学生信息",
            ['curl', '-s', '-X', 'PUT', f'{self.base_url}/api/admin/students/S0201',
             '-H', 'Content-Type: application/json',
             '-d', '{"student_name": "更新的学生姓名"}',
             '-b', self.cookie_file],
            "4_update_student.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e405dba80>
test_number = 4, description = '更新学生信息'
command = ['curl', '-s', '-X', 'PUT', 'http://127.0.0.1:5010/api/admin/students/S0201', '-H', ...]
output_file = '4_update_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 4 异常: 测试 4 失败: API返回错误 - 学生不存在
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
__________________ TestAdminEndpoints.test_05_delete_student ___________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404e0050>
test_number = 5, description = '删除学生'
command = ['curl', '-s', '-X', 'DELETE', 'http://127.0.0.1:5010/api/admin/students/S0201', '-b', ...]
output_file = '5_delete_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 5 失败: API返回错误 - 学生不存在
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404e0050>

    def test_05_delete_student(self):
        """测试用例5: 删除学生"""
>       self.run_api_test(
            5, "删除学生",
            ['curl', '-s', '-X', 'DELETE', f'{self.base_url}/api/admin/students/S0201', '-b', self.cookie_file],
            "5_delete_student.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404e0050>
test_number = 5, description = '删除学生'
command = ['curl', '-s', '-X', 'DELETE', 'http://127.0.0.1:5010/api/admin/students/S0201', '-b', ...]
output_file = '5_delete_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 5 异常: 测试 5 失败: API返回错误 - 学生不存在
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
__________________ TestAdminEndpoints.test_09_update_teacher ___________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e4061b750>
test_number = 9, description = '更新教师信息'
command = ['curl', '-s', '-X', 'PUT', 'http://127.0.0.1:5010/api/admin/teachers/3', '-H', ...]
output_file = '9_update_teacher.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 9 失败: API返回错误 - 教师不存在
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e4061b750>

    def test_09_update_teacher(self):
        """测试用例9: 更新教师信息"""
>       self.run_api_test(
            9, "更新教师信息",
            ['curl', '-s', '-X', 'PUT', f'{self.base_url}/api/admin/teachers/3',
             '-H', 'Content-Type: application/json',
             '-d', '{"teacher_name": "更新的张老师", "subject_id": 2}',
             '-b', self.cookie_file],
            "9_update_teacher.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e4061b750>
test_number = 9, description = '更新教师信息'
command = ['curl', '-s', '-X', 'PUT', 'http://127.0.0.1:5010/api/admin/teachers/3', '-H', ...]
output_file = '9_update_teacher.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 9 异常: 测试 9 失败: API返回错误 - 教师不存在
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
_____________________ TestAdminEndpoints.test_13_get_class _____________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404c5e10>
test_number = 13, description = '获取特定班级'
command = ['curl', '-s', 'http://127.0.0.1:5010/api/admin/classes/1', '-b', '/tmp/test_cookie.txt']
output_file = '13_get_class.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 13 失败: API返回错误 - Class not found
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404c5e10>

    def test_13_get_class(self):
        """测试用例13: 获取特定班级"""
>       self.run_api_test(
            13, "获取特定班级",
            ['curl', '-s', f'{self.base_url}/api/admin/classes/1', '-b', self.cookie_file],
            "13_get_class.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404c5e10>
test_number = 13, description = '获取特定班级'
command = ['curl', '-s', 'http://127.0.0.1:5010/api/admin/classes/1', '-b', '/tmp/test_cookie.txt']
output_file = '13_get_class.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 13 异常: 测试 13 失败: API返回错误 - Class not found
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
_________________ TestAdminEndpoints.test_22_create_exam_type __________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404dfd50>
test_number = 22, description = '创建考试类型'
command = ['curl', '-s', '-X', 'POST', 'http://127.0.0.1:5010/api/admin/exam-types', '-H', ...]
output_file = '22_create_exam_type.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 22 失败: API返回错误 - 创建考试类型失败
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404dfd50>

    def test_22_create_exam_type(self):
        """测试用例22: 创建考试类型"""
>       self.run_api_test(
            22, "创建考试类型",
            ['curl', '-s', '-X', 'POST', f'{self.base_url}/api/admin/exam-types',
             '-H', 'Content-Type: application/json',
             '-d', '{"exam_type_name": "新考试类型1", "description": "考试类型描述"}',
             '-b', self.cookie_file],
            "22_create_exam_type.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404dfd50>
test_number = 22, description = '创建考试类型'
command = ['curl', '-s', '-X', 'POST', 'http://127.0.0.1:5010/api/admin/exam-types', '-H', ...]
output_file = '22_create_exam_type.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 22 异常: 测试 22 失败: API返回错误 - 创建考试类型失败
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
___________________ TestAdminEndpoints.test_23_get_exam_type ___________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404e8250>
test_number = 23, description = '获取特定考试类型'
command = ['curl', '-s', 'http://127.0.0.1:5010/api/admin/exam-types/2', '-b', '/tmp/test_cookie.txt']
output_file = '23_get_exam_type.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 23 失败: API返回错误 - 考试类型不存在
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404e8250>

    def test_23_get_exam_type(self):
        """测试用例23: 获取特定考试类型"""
>       self.run_api_test(
            23, "获取特定考试类型",
            ['curl', '-s', f'{self.base_url}/api/admin/exam-types/2', '-b', self.cookie_file],
            "23_get_exam_type.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404e8250>
test_number = 23, description = '获取特定考试类型'
command = ['curl', '-s', 'http://127.0.0.1:5010/api/admin/exam-types/2', '-b', '/tmp/test_cookie.txt']
output_file = '23_get_exam_type.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 23 异常: 测试 23 失败: API返回错误 - 考试类型不存在
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
_________________ TestAdminEndpoints.test_24_update_exam_type __________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404d14e0>
test_number = 24, description = '更新考试类型信息'
command = ['curl', '-s', '-X', 'PUT', 'http://127.0.0.1:5010/api/admin/exam-types/2', '-H', ...]
output_file = '24_update_exam_type.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 24 失败: API返回错误 - 考试类型不存在
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404d14e0>

    def test_24_update_exam_type(self):
        """测试用例24: 更新考试类型信息"""
>       self.run_api_test(
            24, "更新考试类型信息",
            ['curl', '-s', '-X', 'PUT', f'{self.base_url}/api/admin/exam-types/2',
             '-H', 'Content-Type: application/json',
             '-d', '{"exam_type_name": "更新的考试类型名称"}',
             '-b', self.cookie_file],
            "24_update_exam_type.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404d14e0>
test_number = 24, description = '更新考试类型信息'
command = ['curl', '-s', '-X', 'PUT', 'http://127.0.0.1:5010/api/admin/exam-types/2', '-H', ...]
output_file = '24_update_exam_type.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 24 异常: 测试 24 失败: API返回错误 - 考试类型不存在
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
_________________ TestAdminEndpoints.test_25_delete_exam_type __________________

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404d1630>
test_number = 25, description = '删除考试类型'
command = ['curl', '-s', '-X', 'DELETE', 'http://127.0.0.1:5010/api/admin/exam-types/2', '-b', ...]
output_file = '25_delete_exam_type.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 25 失败: API返回错误 - 考试类型不存在
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404d1630>

    def test_25_delete_exam_type(self):
        """测试用例25: 删除考试类型"""
>       self.run_api_test(
            25, "删除考试类型",
            ['curl', '-s', '-X', 'DELETE', f'{self.base_url}/api/admin/exam-types/2', '-b', self.cookie_file],
            "25_delete_exam_type.json", self.test_setup
        )

tests/test_curl/test_admin_endpoints.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_admin_endpoints.TestAdminEndpoints object at 0x7f6e404d1630>
test_number = 25, description = '删除考试类型'
command = ['curl', '-s', '-X', 'DELETE', 'http://127.0.0.1:5010/api/admin/exam-types/2', '-b', ...]
output_file = '25_delete_exam_type.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/admin_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 25 异常: 测试 25 失败: API返回错误 - 考试类型不存在
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
__________________ TestTeacherEndpoints.test_03_create_score ___________________

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e40548050>
test_number = 3, description = '教师创建学生成绩'
command = ['curl', '-s', '-X', 'POST', 'http://127.0.0.1:5010/api/teacher/scores', '-H', ...]
output_file = '3_create_score.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/teacher_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 3 失败: API返回错误 - Failed to create score
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e40548050>

    def test_03_create_score(self):
        """测试用例3: 教师创建学生成绩"""
>       self.run_api_test(
            3, "教师创建学生成绩",
            ['curl', '-s', '-X', 'POST', f'{self.base_url}/api/teacher/scores',
             '-H', 'Content-Type: application/json',
             '-d', '{"student_id": "S0201", "subject_id": 1, "exam_type_id": 1, "score": 85}',
             '-b', self.cookie_file],
            "3_create_score.json",
            self.test_setup
        )

tests/test_curl/test_teacher_endpoints.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e40548050>
test_number = 3, description = '教师创建学生成绩'
command = ['curl', '-s', '-X', 'POST', 'http://127.0.0.1:5010/api/teacher/scores', '-H', ...]
output_file = '3_create_score.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/teacher_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 3 异常: 测试 3 失败: API返回错误 - Failed to create score
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
___________________ TestTeacherEndpoints.test_17_get_student ___________________

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e40656fc0>
test_number = 17, description = '教师获取特定学生'
command = ['curl', '-s', 'http://127.0.0.1:5010/api/teacher/students/S0201', '-b', '/tmp/test_cookie.txt']
output_file = 'teacher_17_get_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/teacher_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 17 失败: API返回错误 - Student not found or not in your class
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e40656fc0>

    def test_17_get_student(self):
        """测试用例17: 教师获取特定学生"""
>       self.run_api_test(
            17, "教师获取特定学生",
            ['curl', '-s', f'{self.base_url}/api/teacher/students/S0201', '-b', self.cookie_file],
            "teacher_17_get_student.json",
            self.test_setup
        )

tests/test_curl/test_teacher_endpoints.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e40656fc0>
test_number = 17, description = '教师获取特定学生'
command = ['curl', '-s', 'http://127.0.0.1:5010/api/teacher/students/S0201', '-b', '/tmp/test_cookie.txt']
output_file = 'teacher_17_get_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/teacher_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 17 异常: 测试 17 失败: API返回错误 - Student not found or not in your class
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
_________________ TestTeacherEndpoints.test_18_update_student __________________

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e404d62b0>
test_number = 18, description = '教师更新学生信息'
command = ['curl', '-s', '-X', 'PUT', 'http://127.0.0.1:5010/api/teacher/students/S0201', '-H', ...]
output_file = 'teacher_18_update_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/teacher_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
>                   assert False, f"测试 {test_number} 失败: {error_msg}"
E                   AssertionError: 测试 18 失败: API返回错误 - Student not found or not in your class
E                   assert False

tests/test_curl/test_curl_base.py:149: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e404d62b0>

    def test_18_update_student(self):
        """测试用例18: 教师更新学生信息"""
>       self.run_api_test(
            18, "教师更新学生信息",
            ['curl', '-s', '-X', 'PUT', f'{self.base_url}/api/teacher/students/S0201',
             '-H', 'Content-Type: application/json',
             '-d', '{"student_name": "Updated Name"}',
             '-b', self.cookie_file],
            "teacher_18_update_student.json",
            self.test_setup
        )

tests/test_curl/test_teacher_endpoints.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_curl.test_teacher_endpoints.TestTeacherEndpoints object at 0x7f6e404d62b0>
test_number = 18, description = '教师更新学生信息'
command = ['curl', '-s', '-X', 'PUT', 'http://127.0.0.1:5010/api/teacher/students/S0201', '-H', ...]
output_file = 'teacher_18_update_student.json'
test_setup = {'base_url': 'http://127.0.0.1:5010', 'cookie_file': '/tmp/test_cookie.txt', 'curl_commands_file': '/home/jimmy/repo/scout/logs_testing/curl_test/teacher_curl_commands.log', 'result_dir': '/home/jimmy/repo/scout/logs_testing/curl_test'}
expect_error = False

    def run_api_test(self, test_number, description, command, output_file, test_setup, expect_error=False):
        """运行单个API测试"""
        print(f"\n{test_number}. {description}")
        print(f"执行命令: {' '.join(command)}")
        sys.stdout.flush()  # 确保输出被立即刷新
    
        # 记录curl命令
        self._record_curl_command(test_number, description, command)
    
        # 使用shlex.join来正确处理命令参数中的引号
        if '|' not in ' '.join(command):
            # 如果命令中没有管道符，添加jq处理
            full_command = shlex.join(command) + ' | jq'
        else:
            # 如果已经有管道符，直接使用原命令
            full_command = shlex.join(command)
    
        # 执行测试命令
        result = subprocess.run(full_command, shell=True, capture_output=True, text=True)
    
        # 保存结果
        output_path = os.path.join(test_setup['result_dir'], output_file)
        try:
            # 尝试解析为JSON
            json_data = json.loads(result.stdout)
            with open(output_path, 'w') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
    
            # 如果API返回错误
            if 'error' in json_data and json_data['error']:
                error_msg = f"API返回错误 - {json_data['error']}"
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            elif not json_data.get('success', False):
                error_msg = json_data.get('message', '未知错误')
                if expect_error:
                    print(f"测试 {test_number} 完成（预期错误）: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    return True
                else:
                    print(f"测试 {test_number} 失败: {error_msg}")
                    sys.stdout.flush()  # 确保输出被立即刷新
                    assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except json.JSONDecodeError:
            # 如果不是JSON响应，直接保存
            with open(output_path, 'w') as f:
                f.write(result.stdout)
    
            # 检查是否有错误输出
            if result.returncode != 0 or result.stderr:
                error_msg = result.stderr or "命令执行失败"
                print(f"测试 {test_number} 失败: {error_msg}")
                sys.stdout.flush()  # 确保输出被立即刷新
                assert False, f"测试 {test_number} 失败: {error_msg}"
            else:
                print(f"测试 {test_number} 完成")
                sys.stdout.flush()  # 确保输出被立即刷新
                return True
    
        except Exception as e:
            print(f"测试 {test_number} 异常: {str(e)}")
            sys.stdout.flush()  # 确保输出被立即刷新
>           assert False, f"测试 {test_number} 异常: {str(e)}"
E           AssertionError: 测试 18 异常: 测试 18 失败: API返回错误 - Student not found or not in your class
E             assert False
E           assert False

tests/test_curl/test_curl_base.py:184: AssertionError
=========================== short test summary info ============================
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_02_create_student
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_03_get_student
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_04_update_student
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_05_delete_student
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_09_update_teacher
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_13_get_class
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_22_create_exam_type
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_23_get_exam_type
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_24_update_exam_type
FAILED tests/test_curl/test_admin_endpoints.py::TestAdminEndpoints::test_25_delete_exam_type
FAILED tests/test_curl/test_teacher_endpoints.py::TestTeacherEndpoints::test_03_create_score
FAILED tests/test_curl/test_teacher_endpoints.py::TestTeacherEndpoints::test_17_get_student
FAILED tests/test_curl/test_teacher_endpoints.py::TestTeacherEndpoints::test_18_update_student
ERROR tests/test_curl/test_student_endpoints.py::TestStudentEndpoints::test_01_get_grades
=================== 13 failed, 160 passed, 1 error in 9.97s ====================
